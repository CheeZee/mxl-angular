'use strict';

/**
 * Binds a CodeMirror widget to a <textarea> element.
 */
angular.module('ui.codemirror', [])
  .constant('uiCodemirrorConfig', {})
  .directive('uiCodemirror', uiCodemirrorDirective);

/**
 * @ngInject
 */
function uiCodemirrorDirective($timeout, uiCodemirrorConfig, $q) {

    return {
        restrict: 'EA',
        require: '?ngModel',
        priority: 1,
        compile: function compile() {

            // Require CodeMirror
            if (angular.isUndefined(window.CodeMirror)) {
                throw new Error('ui-codemirror need CodeMirror to work... (o rly?)');
            }

            return postLink;
        }
    };

    function postLink($scope, $element, $attrs, ctrl) {
        
        var codemirrorOptions = angular.extend(
          { value: $element.text() },
          uiCodemirrorConfig.codemirror || {},
          $scope.$eval($attrs.uiCodemirror),
          $scope.$eval($attrs.uiCodemirrorOpts)
        );

        var codemirror = newCodemirrorEditor($element, codemirrorOptions);

        configOptionsWatcher(
          codemirror,
          $attrs.uiCodemirror || $attrs.uiCodemirrorOpts,
          $scope
        );

        configNgModelLink(codemirror, ctrl, $scope);

        configUiRefreshAttribute(codemirror, $attrs.uiRefresh, $scope);

        // Allow access to the CodeMirror instance through a broadcasted event
        // eg: $broadcast('CodeMirror', function(cm){...});
        $scope.$on('CodeMirror', function (event, callback) {
            if (angular.isFunction(callback)) {
                callback(codemirror);
            } else {
                throw new Error('the CodeMirror event requires a callback function');
            }
        });

        // onLoad callback
        if (angular.isFunction(codemirrorOptions.onLoad)) {
            codemirrorOptions.onLoad(codemirror);
        }
    }

    function newCodemirrorEditor($element, codemirrorOptions) {
        var codemirrot;
        console.log($element);
        if ($element[0].tagName === 'TEXTAREA') {
            // Might bug but still ...
            codemirrot = window.CodeMirror.fromTextArea($element[0], codemirrorOptions);
        } else {
            $element.html('');
            codemirrot = new window.CodeMirror(function (cm_el) {
                $element.append(cm_el);
            }, codemirrorOptions);
        }

        return codemirrot;
    }

    function configOptionsWatcher(codemirrot, uiCodemirrorAttr, $scope) {
        if (!uiCodemirrorAttr) { return; }

        var codemirrorDefaultsKeys = Object.keys(window.CodeMirror.defaults);
        $scope.$watch(uiCodemirrorAttr, updateOptions, true);
        function updateOptions(newValues, oldValue) {
            if (!angular.isObject(newValues)) { return; }
            codemirrorDefaultsKeys.forEach(function (key) {
                if (newValues.hasOwnProperty(key)) {

                    if (oldValue && newValues[key] === oldValue[key]) {
                        return;
                    }

                    codemirrot.setOption(key, newValues[key]);
                }
            });
        }
    }

    function configNgModelLink(codemirror, ctrl, $scope) {
        if (!ctrl) { return; }
        // CodeMirror expects a string, so make sure it gets one.
        // This does not change the model.
        ctrl.$formatters.push(function (value) {
            if (angular.isUndefined(value) || value === null) {
                return '';
            } else if (angular.isObject(value) || angular.isArray(value)) {
                throw new Error('ui-codemirror cannot use an object or an array as a model');
            }
            return value;
        });


        // Override the ngModelController $render method, which is what gets called when the model is updated.
        // This takes care of the synchronizing the codeMirror element with the underlying model, in the case that it is changed by something else.
        ctrl.$render = function () {
            //Code mirror expects a string so make sure it gets one
            //Although the formatter have already done this, it can be possible that another formatter returns undefined (for example the required directive)
            var safeViewValue = ctrl.$viewValue || '';
            codemirror.setValue(safeViewValue);
        };

        // Validate the static sematnics of the code editor' value by performing an MxL type check
        ctrl.$asyncValidators.typeChecking = function (modelValue, viewValue) {
            if (codemirror.options.validateMxl) {
                return codemirror.options.validateMxl(modelValue, viewValue);
            }
            return $q.when();
        };

        // Keep the ngModel in sync with changes from CodeMirror
        codemirror.on('change', function (instance) {
            var newValue = instance.getValue();
            if (newValue !== ctrl.$viewValue) {
                if (codemirror.options.debounce) {
                    if ($scope.debounceUpdate) {
                        $timeout.cancel($scope.debounceUpdate);
                    }

                    $scope.$evalAsync(function () {
                        $scope.debounceUpdate = $timeout(function () {
                            ctrl.$setViewValue(newValue);
                        }, codemirror.options.debounce);
                    });
                }
                else {

                    $scope.$evalAsync(function () {
                        ctrl.$setViewValue(newValue);
                    });
                }
            }
        });

        codemirror.on('blur', function (instance) {
            var newValue = instance.getValue();
            if (newValue !== ctrl.$viewValue) {
                $scope.$evalAsync(function () {
                    ctrl.$setViewValue(newValue);
                });
            }
        });
    }

    function configUiRefreshAttribute(codeMirror, uiRefreshAttr, $scope) {
        if (!uiRefreshAttr) { return; }

        $scope.$watch(uiRefreshAttr, function (newVal, oldVal) {
            // Skip the initial watch firing
            if (newVal !== oldVal) {
                $timeout(function () {
                    codeMirror.refresh();
                });
            }
        });
    }

}