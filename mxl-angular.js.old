angular.module('mxl', ['ui.codemirror'])
.directive('mxlExpression', function ($timeout, $q, uiCodemirrorConfig) {
    return {
        restrict: 'E',
        require: ["^ngModel"],
        scope:
            {
                expression: '=ngModel',
                lineNumbers: '@mxlLinenumbers',
                additionalAutoCompletionHints: '=mxlAutocompletionhints',
                runTest: '&mxlRuntest',
                validateMxL: '&mxlValidate',
                name: '@'
            },
        controller: function ($scope) {
            $scope.codeMirrorLoaded = function (cm) {
                $scope.codemirror = cm;
            };

            var codemirrorOptions = {
                lineWrapping: true,
                matchBrackets: true,
                autoCloseBrackets: true,
                highlightSelectionMatches: { showToken: /\w/ },
                viewportMargin: Infinity,
                lineNumbers: $scope.lineNumbers && $scope.lineNumbers === "true",
                mode: 'mxl',
                gutters: ["CodeMirror-lint-markers"],
                lint: true,
                debounce: 2000,
                theme: 'mxl',
                extraKeys: {
                    "Ctrl-Space": "autocomplete",
                    "Tab": false,
                    "Shift-Tab": false,
                    "'.'": function (cm) {
                        $timeout(function () { cm.execCommand("autocomplete"); }, 100, false);
                        return CodeMirror.Pass;
                    },
                    "esc": function (cm) {
                        return CodeMirror.Pass;
                    }
                }
            };

            if ($scope.validateMxL && angular.isFunction($scope.validateMxL)) {
                codemirrorOptions.validateMxl = function (modelValue, viewValue) {
                    function updateLints(currentError) {
                        if ($scope.codemirror.options.updateMxLLints) {
                            $scope.codemirror.options.updateMxLLints($scope.codemirror, currentError);
                        }
                    }

                    return $scope.validateMxL({ modelValue: modelValue, viewValue: viewValue })
                        .success(function (data, status, headers, config) {
                            updateLints(null);

                        }).error(function (data, status, headers, config) {
                            updateLints(data);

                        });
                };
            }

            if ($scope.runTest && angular.isFunction($scope.runTest)) {
                codemirrorOptions.extraKeys["Ctrl-Enter"] = function (cm) {
                    $scope.runTest({ value: cm.getValue() });
                }
            }

            uiCodemirrorConfig.codemirror = codemirrorOptions;

            CodeMirror.commands.autocomplete = function (cmeditor) {
                var autoCompletionOptions = { completeSingle: false };

                if ($scope.additionalAutoCompletionHints) {
                    autoCompletionOptions.additionalHints = $scope.additionalAutoCompletionHints;
                }

                CodeMirror.showHint(cmeditor, CodeMirror.hint.mxl, autoCompletionOptions);
            };
        },
        templateUrl: 'mxl/mxl-template.html'
    }
});